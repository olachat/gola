// Code generated by gola 0.1.1; DO NOT EDIT.

package users

import (
	"database/sql"
	"encoding/json"
	"reflect"
	"strings"

	"github.com/olachat/gola/v2/coredb"
)

const DBName string = "testdata"
const TableName string = "users"

// User represents `users` table
type User struct {
	//  int(11)
	Id `json:"id"`
	// Name varchar(255)
	Name `json:"name"`
	// Email address varchar(255)
	Email `json:"email"`
	// Created Timestamp int(11) unsigned
	CreatedAt `json:"created_at"`
	// Updated Timestamp int(11) unsigned
	UpdatedAt `json:"updated_at"`
	// float float
	FloatType `json:"float_type"`
	// double double
	DoubleType `json:"double_type"`
	// user hobby enum('swimming','running','singing')
	Hobby `json:"hobby"`
	// user hobby enum('swimming','running','singing')
	HobbyNoDefault `json:"hobby_no_default"`
	// user sports set('swim','tennis','basketball','football','squash','badminton')
	Sports `json:"sports"`
	// user sports set('swim','tennis','basketball','football','squash','badminton')
	Sports2 `json:"sports2"`
	// user sports set('swim','tennis','basketball','football','squash','badminton')
	SportsNoDefault `json:"sports_no_default"`
}

type withPK interface {
	GetId() int
}

// FetchByPK returns a row from `users` table with given primary key value
//
// Deprecated: use the function with context
func FetchByPK(val int) *User {
	return coredb.FetchByPK[User](DBName, TableName, []string{"id"}, val)
}

// FetchFieldsByPK returns a row with selected fields from users table with given primary key value
//
// Deprecated: use the function with context
func FetchFieldsByPK[T any](val int) *T {
	return coredb.FetchByPK[T](DBName, TableName, []string{"id"}, val)
}

// FetchByPKs returns rows with from `users` table with given primary key values
//
// Deprecated: use the function with context
func FetchByPKs(vals ...int) []*User {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKs[User](DBName, TableName, "id", pks)
}

// FetchFieldsByPKs returns rows with selected fields from `users` table with given primary key values
//
// Deprecated: use the function with context
func FetchFieldsByPKs[T any](vals ...int) []*T {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKs[T](DBName, TableName, "id", pks)
}

// FindOne returns a row from `users` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOne(whereSQL string, params ...any) *User {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOne[User](DBName, TableName, w)
}

// FindOneFields returns a row with selected fields from `users` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFields[T any](whereSQL string, params ...any) *T {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOne[T](DBName, TableName, w)
}

// Find returns rows from `users` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func Find(whereSQL string, params ...any) ([]*User, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.Find[User](DBName, TableName, w)
}

// FindFields returns rows with selected fields from `users` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFields[T any](whereSQL string, params ...any) ([]*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.Find[T](DBName, TableName, w)
}

// Count returns select count(*) with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func Count(whereSQL string, params ...any) (int, error) {
	return coredb.QueryInt(DBName, "SELECT COUNT(*) FROM `users` "+whereSQL, params...)
}

// FetchByPK returns a row from `users` table with given primary key value
//
// Deprecated: use the function with context
func FetchByPKFromMaster(val int) *User {
	return coredb.FetchByPKFromMaster[User](DBName, TableName, []string{"id"}, val)
}

// FetchFieldsByPK returns a row with selected fields from users table with given primary key value
//
// Deprecated: use the function with context
func FetchFieldsByPKFromMaster[T any](val int) *T {
	return coredb.FetchByPKFromMaster[T](DBName, TableName, []string{"id"}, val)
}

// FetchByPKs returns rows with from `users` table with given primary key values
//
// Deprecated: use the function with context
func FetchByPKsFromMaster(vals ...int) []*User {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKsFromMaster[User](DBName, TableName, "id", pks)
}

// FetchFieldsByPKs returns rows with selected fields from `users` table with given primary key values
//
// Deprecated: use the function with context
func FetchFieldsByPKsFromMaster[T any](vals ...int) []*T {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKsFromMaster[T](DBName, TableName, "id", pks)
}

// FindOne returns a row from `users` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFromMaster(whereSQL string, params ...any) *User {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneFromMaster[User](DBName, TableName, w)
}

// FindOneFields returns a row with selected fields from `users` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFieldsFromMaster[T any](whereSQL string, params ...any) *T {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneFromMaster[T](DBName, TableName, w)
}

// Find returns rows from `users` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFromMaster(whereSQL string, params ...any) ([]*User, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindFromMaster[User](DBName, TableName, w)
}

// FindFields returns rows with selected fields from `users` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFieldsFromMaster[T any](whereSQL string, params ...any) ([]*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindFromMaster[T](DBName, TableName, w)
}

// Count returns select count(*) with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func CountFromMaster(whereSQL string, params ...any) (int, error) {
	return coredb.QueryIntFromMaster(DBName, "SELECT COUNT(*) FROM `users` "+whereSQL, params...)
}

// Column types
type UserHobby string

const (
	UserHobbySwimming UserHobby = "swimming"
	UserHobbyRunning  UserHobby = "running"
	UserHobbySinging  UserHobby = "singing"
)

type UserHobbyNoDefault string

const (
	UserHobbyNoDefaultSwimming UserHobbyNoDefault = "swimming"
	UserHobbyNoDefaultRunning  UserHobbyNoDefault = "running"
	UserHobbyNoDefaultSinging  UserHobbyNoDefault = "singing"
)

type UserSports string

const (
	UserSportsSwim       UserSports = "swim"
	UserSportsTennis     UserSports = "tennis"
	UserSportsBasketball UserSports = "basketball"
	UserSportsFootball   UserSports = "football"
	UserSportsSquash     UserSports = "squash"
	UserSportsBadminton  UserSports = "badminton"
)

var UserSportsList = []string{
	"swim",
	"tennis",
	"basketball",
	"football",
	"squash",
	"badminton",
}

type UserSports2 string

const (
	UserSports2Swim       UserSports2 = "swim"
	UserSports2Tennis     UserSports2 = "tennis"
	UserSports2Basketball UserSports2 = "basketball"
	UserSports2Football   UserSports2 = "football"
	UserSports2Squash     UserSports2 = "squash"
	UserSports2Badminton  UserSports2 = "badminton"
)

var UserSports2List = []string{
	"swim",
	"tennis",
	"basketball",
	"football",
	"squash",
	"badminton",
}

type UserSportsNoDefault string

const (
	UserSportsNoDefaultSwim       UserSportsNoDefault = "swim"
	UserSportsNoDefaultTennis     UserSportsNoDefault = "tennis"
	UserSportsNoDefaultBasketball UserSportsNoDefault = "basketball"
	UserSportsNoDefaultFootball   UserSportsNoDefault = "football"
	UserSportsNoDefaultSquash     UserSportsNoDefault = "squash"
	UserSportsNoDefaultBadminton  UserSportsNoDefault = "badminton"
)

var UserSportsNoDefaultList = []string{
	"swim",
	"tennis",
	"basketball",
	"football",
	"squash",
	"badminton",
}

// Id field
type Id struct {
	isAssigned bool
	val        int
}

func (c *Id) GetId() int {
	return c.val
}

func (c *Id) GetColumnName() string {
	return "id"
}

func (c *Id) GetValPointer() any {
	return &c.val
}

func (c *Id) getIdForDB() int {
	return c.val
}

func (c *Id) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Id) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Name field
// Name
type Name struct {
	_updated bool
	val      string
}

func (c *Name) GetName() string {
	return c.val
}

func (c *Name) SetName(val string) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Name) IsUpdated() bool {
	return c._updated
}

func (c *Name) resetUpdated() {
	c._updated = false
}

func (c *Name) GetColumnName() string {
	return "name"
}

func (c *Name) GetValPointer() any {
	return &c.val
}

func (c *Name) getNameForDB() string {
	return c.val
}

func (c *Name) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Name) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Email field
// Email address
type Email struct {
	_updated bool
	val      string
}

func (c *Email) GetEmail() string {
	return c.val
}

func (c *Email) SetEmail(val string) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Email) IsUpdated() bool {
	return c._updated
}

func (c *Email) resetUpdated() {
	c._updated = false
}

func (c *Email) GetColumnName() string {
	return "email"
}

func (c *Email) GetValPointer() any {
	return &c.val
}

func (c *Email) getEmailForDB() string {
	return c.val
}

func (c *Email) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Email) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// CreatedAt field
// Created Timestamp
type CreatedAt struct {
	_updated bool
	val      uint
}

func (c *CreatedAt) GetCreatedAt() uint {
	return c.val
}

func (c *CreatedAt) SetCreatedAt(val uint) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *CreatedAt) IsUpdated() bool {
	return c._updated
}

func (c *CreatedAt) resetUpdated() {
	c._updated = false
}

func (c *CreatedAt) GetColumnName() string {
	return "created_at"
}

func (c *CreatedAt) GetValPointer() any {
	return &c.val
}

func (c *CreatedAt) getCreatedAtForDB() uint {
	return c.val
}

func (c *CreatedAt) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *CreatedAt) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// UpdatedAt field
// Updated Timestamp
type UpdatedAt struct {
	_updated bool
	val      uint
}

func (c *UpdatedAt) GetUpdatedAt() uint {
	return c.val
}

func (c *UpdatedAt) SetUpdatedAt(val uint) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *UpdatedAt) IsUpdated() bool {
	return c._updated
}

func (c *UpdatedAt) resetUpdated() {
	c._updated = false
}

func (c *UpdatedAt) GetColumnName() string {
	return "updated_at"
}

func (c *UpdatedAt) GetValPointer() any {
	return &c.val
}

func (c *UpdatedAt) getUpdatedAtForDB() uint {
	return c.val
}

func (c *UpdatedAt) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *UpdatedAt) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// FloatType field
// float
type FloatType struct {
	_updated bool
	val      float64
}

func (c *FloatType) GetFloatType() float64 {
	return c.val
}

func (c *FloatType) SetFloatType(val float64) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *FloatType) IsUpdated() bool {
	return c._updated
}

func (c *FloatType) resetUpdated() {
	c._updated = false
}

func (c *FloatType) GetColumnName() string {
	return "float_type"
}

func (c *FloatType) GetValPointer() any {
	return &c.val
}

func (c *FloatType) getFloatTypeForDB() float64 {
	return c.val
}

func (c *FloatType) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *FloatType) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// DoubleType field
// double
type DoubleType struct {
	_updated bool
	val      float64
}

func (c *DoubleType) GetDoubleType() float64 {
	return c.val
}

func (c *DoubleType) SetDoubleType(val float64) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *DoubleType) IsUpdated() bool {
	return c._updated
}

func (c *DoubleType) resetUpdated() {
	c._updated = false
}

func (c *DoubleType) GetColumnName() string {
	return "double_type"
}

func (c *DoubleType) GetValPointer() any {
	return &c.val
}

func (c *DoubleType) getDoubleTypeForDB() float64 {
	return c.val
}

func (c *DoubleType) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *DoubleType) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Hobby field
// user hobby
type Hobby struct {
	_updated bool
	val      UserHobby
}

func (c *Hobby) GetHobby() UserHobby {
	return c.val
}

func (c *Hobby) SetHobby(val UserHobby) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Hobby) IsUpdated() bool {
	return c._updated
}

func (c *Hobby) resetUpdated() {
	c._updated = false
}

func (c *Hobby) GetColumnName() string {
	return "hobby"
}

func (c *Hobby) GetValPointer() any {
	return &c.val
}

func (c *Hobby) getHobbyForDB() UserHobby {
	return c.val
}

func (c *Hobby) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Hobby) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// HobbyNoDefault field
// user hobby
type HobbyNoDefault struct {
	_updated bool
	val      UserHobbyNoDefault
}

func (c *HobbyNoDefault) GetHobbyNoDefault() UserHobbyNoDefault {
	return c.val
}

func (c *HobbyNoDefault) SetHobbyNoDefault(val UserHobbyNoDefault) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *HobbyNoDefault) IsUpdated() bool {
	return c._updated
}

func (c *HobbyNoDefault) resetUpdated() {
	c._updated = false
}

func (c *HobbyNoDefault) GetColumnName() string {
	return "hobby_no_default"
}

func (c *HobbyNoDefault) GetValPointer() any {
	return &c.val
}

func (c *HobbyNoDefault) getHobbyNoDefaultForDB() UserHobbyNoDefault {
	return c.val
}

func (c *HobbyNoDefault) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *HobbyNoDefault) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Sports field
// user sports
type Sports struct {
	_updated bool
	val      string
}

func (c *Sports) GetSports() []UserSports {
	strSlice := strings.Split(c.val, ",")
	if len(strSlice) == 1 && !coredb.ValueInSet(UserSportsList, strSlice[0]) {
		return []UserSports{}
	}
	valSlice := make([]UserSports, 0, len(strSlice))
	for _, s := range strSlice {
		valSlice = append(valSlice, UserSports(strings.ToLower(s)))
	}
	return valSlice
}

func (c *Sports) SetSports(val []UserSports) bool {
	strSlice := make([]string, 0, len(val))
	for _, v := range val {
		strSlice = append(strSlice, string(v))
	}
	c.val = strings.Join(strSlice, ",")
	c._updated = true
	return true
}

func (c *Sports) IsUpdated() bool {
	return c._updated
}

func (c *Sports) resetUpdated() {
	c._updated = false
}

func (c *Sports) GetColumnName() string {
	return "sports"
}

func (c *Sports) GetValPointer() any {
	return &c.val
}

func (c *Sports) getSportsForDB() string {
	return c.val
}

func (c *Sports) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Sports) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Sports2 field
// user sports
type Sports2 struct {
	_updated bool
	val      string
}

func (c *Sports2) GetSports2() []UserSports2 {
	strSlice := strings.Split(c.val, ",")
	if len(strSlice) == 1 && !coredb.ValueInSet(UserSports2List, strSlice[0]) {
		return []UserSports2{}
	}
	valSlice := make([]UserSports2, 0, len(strSlice))
	for _, s := range strSlice {
		valSlice = append(valSlice, UserSports2(strings.ToLower(s)))
	}
	return valSlice
}

func (c *Sports2) SetSports2(val []UserSports2) bool {
	strSlice := make([]string, 0, len(val))
	for _, v := range val {
		strSlice = append(strSlice, string(v))
	}
	c.val = strings.Join(strSlice, ",")
	c._updated = true
	return true
}

func (c *Sports2) IsUpdated() bool {
	return c._updated
}

func (c *Sports2) resetUpdated() {
	c._updated = false
}

func (c *Sports2) GetColumnName() string {
	return "sports2"
}

func (c *Sports2) GetValPointer() any {
	return &c.val
}

func (c *Sports2) getSports2ForDB() string {
	return c.val
}

func (c *Sports2) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Sports2) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// SportsNoDefault field
// user sports
type SportsNoDefault struct {
	_updated bool
	val      string
}

func (c *SportsNoDefault) GetSportsNoDefault() []UserSportsNoDefault {
	strSlice := strings.Split(c.val, ",")
	if len(strSlice) == 1 && !coredb.ValueInSet(UserSportsNoDefaultList, strSlice[0]) {
		return []UserSportsNoDefault{}
	}
	valSlice := make([]UserSportsNoDefault, 0, len(strSlice))
	for _, s := range strSlice {
		valSlice = append(valSlice, UserSportsNoDefault(strings.ToLower(s)))
	}
	return valSlice
}

func (c *SportsNoDefault) SetSportsNoDefault(val []UserSportsNoDefault) bool {
	strSlice := make([]string, 0, len(val))
	for _, v := range val {
		strSlice = append(strSlice, string(v))
	}
	c.val = strings.Join(strSlice, ",")
	c._updated = true
	return true
}

func (c *SportsNoDefault) IsUpdated() bool {
	return c._updated
}

func (c *SportsNoDefault) resetUpdated() {
	c._updated = false
}

func (c *SportsNoDefault) GetColumnName() string {
	return "sports_no_default"
}

func (c *SportsNoDefault) GetValPointer() any {
	return &c.val
}

func (c *SportsNoDefault) getSportsNoDefaultForDB() string {
	return c.val
}

func (c *SportsNoDefault) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *SportsNoDefault) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// New return new *User with default values
func New() *User {
	return &User{
		Id{},
		Name{},
		Email{},
		CreatedAt{val: uint(0)},
		UpdatedAt{val: uint(0)},
		FloatType{val: float64(0.0)},
		DoubleType{val: float64(0.0)},
		Hobby{val: "swimming"},
		HobbyNoDefault{},
		Sports{val: "swim,football"},
		Sports2{val: "swim,football"},
		SportsNoDefault{},
	}
}

// NewWithPK takes "id"
// and returns new *User with given PK
func NewWithPK(val int) *User {
	c := &User{
		Id{},
		Name{},
		Email{},
		CreatedAt{val: uint(0)},
		UpdatedAt{val: uint(0)},
		FloatType{val: float64(0.0)},
		DoubleType{val: float64(0.0)},
		Hobby{val: "swimming"},
		HobbyNoDefault{},
		Sports{val: "swim,football"},
		Sports2{val: "swim,football"},
		SportsNoDefault{},
	}
	c.Id.val = val
	c.Id.isAssigned = true
	return c
}

const insertWithoutPK string = "INSERT INTO `users` (`name`, `email`, `created_at`, `updated_at`, `float_type`, `double_type`, `hobby`, `hobby_no_default`, `sports`, `sports2`, `sports_no_default`) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"
const insertWithPK string = "INSERT INTO `users` (`id`, `name`, `email`, `created_at`, `updated_at`, `float_type`, `double_type`, `hobby`, `hobby_no_default`, `sports`, `sports2`, `sports_no_default`) values (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)"

// Insert User struct to `users` table
// Deprecated: use the function with context
func (c *User) Insert() error {
	var result sql.Result
	var err error
	if c.Id.isAssigned {
		result, err = coredb.Exec(DBName, insertWithPK, c.getIdForDB(), c.getNameForDB(), c.getEmailForDB(), c.getCreatedAtForDB(), c.getUpdatedAtForDB(), c.getFloatTypeForDB(), c.getDoubleTypeForDB(), c.getHobbyForDB(), c.getHobbyNoDefaultForDB(), c.getSportsForDB(), c.getSports2ForDB(), c.getSportsNoDefaultForDB())
		if err != nil {
			return err
		}
	} else {
		result, err = coredb.Exec(DBName, insertWithoutPK, c.getNameForDB(), c.getEmailForDB(), c.getCreatedAtForDB(), c.getUpdatedAtForDB(), c.getFloatTypeForDB(), c.getDoubleTypeForDB(), c.getHobbyForDB(), c.getHobbyNoDefaultForDB(), c.getSportsForDB(), c.getSports2ForDB(), c.getSportsNoDefaultForDB())
		if err != nil {
			return err
		}

		id, err := result.LastInsertId()
		if err != nil {
			return err
		}
		c.Id.val = int(id)
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if affectedRows == 0 {
		return coredb.ErrAvoidInsert
	}

	c.resetUpdated()
	return nil
}

func (c *User) resetUpdated() {
	c.Name.resetUpdated()
	c.Email.resetUpdated()
	c.CreatedAt.resetUpdated()
	c.UpdatedAt.resetUpdated()
	c.FloatType.resetUpdated()
	c.DoubleType.resetUpdated()
	c.Hobby.resetUpdated()
	c.HobbyNoDefault.resetUpdated()
	c.Sports.resetUpdated()
	c.Sports2.resetUpdated()
	c.SportsNoDefault.resetUpdated()
}

// Update User struct in `users` table
// Deprecated: use the function with context
func (obj *User) Update() (bool, error) {
	var updatedFields []string
	var params []any
	if obj.Name.IsUpdated() {
		updatedFields = append(updatedFields, "`name` = ?")
		params = append(params, obj.getNameForDB())
	}
	if obj.Email.IsUpdated() {
		updatedFields = append(updatedFields, "`email` = ?")
		params = append(params, obj.getEmailForDB())
	}
	if obj.CreatedAt.IsUpdated() {
		updatedFields = append(updatedFields, "`created_at` = ?")
		params = append(params, obj.getCreatedAtForDB())
	}
	if obj.UpdatedAt.IsUpdated() {
		updatedFields = append(updatedFields, "`updated_at` = ?")
		params = append(params, obj.getUpdatedAtForDB())
	}
	if obj.FloatType.IsUpdated() {
		updatedFields = append(updatedFields, "`float_type` = ?")
		params = append(params, obj.getFloatTypeForDB())
	}
	if obj.DoubleType.IsUpdated() {
		updatedFields = append(updatedFields, "`double_type` = ?")
		params = append(params, obj.getDoubleTypeForDB())
	}
	if obj.Hobby.IsUpdated() {
		updatedFields = append(updatedFields, "`hobby` = ?")
		params = append(params, obj.getHobbyForDB())
	}
	if obj.HobbyNoDefault.IsUpdated() {
		updatedFields = append(updatedFields, "`hobby_no_default` = ?")
		params = append(params, obj.getHobbyNoDefaultForDB())
	}
	if obj.Sports.IsUpdated() {
		updatedFields = append(updatedFields, "`sports` = ?")
		params = append(params, obj.getSportsForDB())
	}
	if obj.Sports2.IsUpdated() {
		updatedFields = append(updatedFields, "`sports2` = ?")
		params = append(params, obj.getSports2ForDB())
	}
	if obj.SportsNoDefault.IsUpdated() {
		updatedFields = append(updatedFields, "`sports_no_default` = ?")
		params = append(params, obj.getSportsNoDefaultForDB())
	}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE `users` SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE `id` = ?"
	params = append(params, obj.GetId())

	result, err := coredb.Exec(DBName, sql, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	obj.resetUpdated()
	return true, nil
}

// Update User struct with given fields in `users` table
// Deprecated: use the function with context
func Update(obj withPK) (bool, error) {
	var updatedFields []string
	var params []any
	var resetFuncs []func()

	val := reflect.ValueOf(obj).Elem()
	updatedFields = make([]string, 0, val.NumField())
	params = make([]any, 0, val.NumField())

	for i := 0; i < val.NumField(); i++ {
		col := val.Field(i).Addr().Interface()

		switch c := col.(type) {
		case *Name:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`name` = ?")
				params = append(params, c.getNameForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Email:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`email` = ?")
				params = append(params, c.getEmailForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *CreatedAt:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`created_at` = ?")
				params = append(params, c.getCreatedAtForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *UpdatedAt:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`updated_at` = ?")
				params = append(params, c.getUpdatedAtForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *FloatType:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`float_type` = ?")
				params = append(params, c.getFloatTypeForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *DoubleType:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`double_type` = ?")
				params = append(params, c.getDoubleTypeForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Hobby:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`hobby` = ?")
				params = append(params, c.getHobbyForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *HobbyNoDefault:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`hobby_no_default` = ?")
				params = append(params, c.getHobbyNoDefaultForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Sports:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`sports` = ?")
				params = append(params, c.getSportsForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Sports2:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`sports2` = ?")
				params = append(params, c.getSports2ForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *SportsNoDefault:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`sports_no_default` = ?")
				params = append(params, c.getSportsNoDefaultForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		}
	}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE `users` SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE `id` = ?"
	params = append(params, obj.GetId())

	result, err := coredb.Exec(DBName, sql, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	for _, f := range resetFuncs {
		f()
	}
	return true, nil
}

const deleteSql string = "DELETE FROM `users` WHERE `id` = ?"

// DeleteByPK delete a row from users table with given primary key value
// Deprecated: use the function with context
func DeleteByPK(val int) error {
	_, err := coredb.Exec(DBName, deleteSql, val)
	return err
}
