// Code generated by gola 0.1.1; DO NOT EDIT.

package songs

import (
	"database/sql"
	"encoding/json"
	"reflect"
	"strings"

	"github.com/olachat/gola/v2/coredb"

	"github.com/jordan-bonecutter/goption"
)

const DBName string = "testdata"
const TableName string = "songs"

// Song represents `songs` table
type Song struct {
	//  int(10) unsigned
	Id `json:"id"`
	// Song title varchar(100)
	Title `json:"title"`
	// Song Ranking mediumint(8)
	Rank `json:"rank"`
	//  enum('','101','1+9','%1','0.9')
	Type `json:"type"`
	// Song file hash checksum varchar(128)
	Hash `json:"hash"`
	//  varchar(128)
	Remark `json:"remark"`
	//  varbinary(255) binary
	Manifest `json:"manifest"`
}

type withPK interface {
	GetId() uint
}

// FetchByPK returns a row from `songs` table with given primary key value
//
// Deprecated: use the function with context
func FetchByPK(val uint) *Song {
	return coredb.FetchByPK[Song](DBName, TableName, []string{"id"}, val)
}

// FetchFieldsByPK returns a row with selected fields from songs table with given primary key value
//
// Deprecated: use the function with context
func FetchFieldsByPK[T any](val uint) *T {
	return coredb.FetchByPK[T](DBName, TableName, []string{"id"}, val)
}

// FetchByPKs returns rows with from `songs` table with given primary key values
//
// Deprecated: use the function with context
func FetchByPKs(vals ...uint) []*Song {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKs[Song](DBName, TableName, "id", pks)
}

// FetchFieldsByPKs returns rows with selected fields from `songs` table with given primary key values
//
// Deprecated: use the function with context
func FetchFieldsByPKs[T any](vals ...uint) []*T {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKs[T](DBName, TableName, "id", pks)
}

// FindOne returns a row from `songs` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOne(whereSQL string, params ...any) *Song {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOne[Song](DBName, TableName, w)
}

// FindOneFields returns a row with selected fields from `songs` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFields[T any](whereSQL string, params ...any) *T {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOne[T](DBName, TableName, w)
}

// Find returns rows from `songs` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func Find(whereSQL string, params ...any) ([]*Song, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.Find[Song](DBName, TableName, w)
}

// FindFields returns rows with selected fields from `songs` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFields[T any](whereSQL string, params ...any) ([]*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.Find[T](DBName, TableName, w)
}

// Count returns select count(*) with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func Count(whereSQL string, params ...any) (int, error) {
	return coredb.QueryInt(DBName, "SELECT COUNT(*) FROM `songs` "+whereSQL, params...)
}

// FetchByPK returns a row from `songs` table with given primary key value
//
// Deprecated: use the function with context
func FetchByPKFromMaster(val uint) *Song {
	return coredb.FetchByPKFromMaster[Song](DBName, TableName, []string{"id"}, val)
}

// FetchFieldsByPK returns a row with selected fields from songs table with given primary key value
//
// Deprecated: use the function with context
func FetchFieldsByPKFromMaster[T any](val uint) *T {
	return coredb.FetchByPKFromMaster[T](DBName, TableName, []string{"id"}, val)
}

// FetchByPKs returns rows with from `songs` table with given primary key values
//
// Deprecated: use the function with context
func FetchByPKsFromMaster(vals ...uint) []*Song {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKsFromMaster[Song](DBName, TableName, "id", pks)
}

// FetchFieldsByPKs returns rows with selected fields from `songs` table with given primary key values
//
// Deprecated: use the function with context
func FetchFieldsByPKsFromMaster[T any](vals ...uint) []*T {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKsFromMaster[T](DBName, TableName, "id", pks)
}

// FindOne returns a row from `songs` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFromMaster(whereSQL string, params ...any) *Song {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneFromMaster[Song](DBName, TableName, w)
}

// FindOneFields returns a row with selected fields from `songs` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFieldsFromMaster[T any](whereSQL string, params ...any) *T {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneFromMaster[T](DBName, TableName, w)
}

// Find returns rows from `songs` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFromMaster(whereSQL string, params ...any) ([]*Song, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindFromMaster[Song](DBName, TableName, w)
}

// FindFields returns rows with selected fields from `songs` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFieldsFromMaster[T any](whereSQL string, params ...any) ([]*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindFromMaster[T](DBName, TableName, w)
}

// Count returns select count(*) with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func CountFromMaster(whereSQL string, params ...any) (int, error) {
	return coredb.QueryIntFromMaster(DBName, "SELECT COUNT(*) FROM `songs` "+whereSQL, params...)
}

// Column types
type SongType string

const (
	SongTypeEmpty SongType = ""
	SongType101   SongType = "101"
	SongType1x2B9 SongType = "1+9"
	SongTypex251  SongType = "%1"
	SongType0dot9 SongType = "0.9"
)

// Id field
type Id struct {
	isAssigned bool
	val        uint
}

func (c *Id) GetId() uint {
	return c.val
}

func (c *Id) GetColumnName() string {
	return "id"
}

func (c *Id) GetValPointer() any {
	return &c.val
}

func (c *Id) getIdForDB() uint {
	return c.val
}

func (c *Id) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Id) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Title field
// Song title
type Title struct {
	_updated bool
	val      string
}

func (c *Title) GetTitle() string {
	return c.val
}

func (c *Title) SetTitle(val string) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Title) IsUpdated() bool {
	return c._updated
}

func (c *Title) resetUpdated() {
	c._updated = false
}

func (c *Title) GetColumnName() string {
	return "title"
}

func (c *Title) GetValPointer() any {
	return &c.val
}

func (c *Title) getTitleForDB() string {
	return c.val
}

func (c *Title) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Title) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Rank field
// Song Ranking
type Rank struct {
	_updated bool
	val      int
}

func (c *Rank) GetRank() int {
	return c.val
}

func (c *Rank) SetRank(val int) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Rank) IsUpdated() bool {
	return c._updated
}

func (c *Rank) resetUpdated() {
	c._updated = false
}

func (c *Rank) GetColumnName() string {
	return "rank"
}

func (c *Rank) GetValPointer() any {
	return &c.val
}

func (c *Rank) getRankForDB() int {
	return c.val
}

func (c *Rank) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Rank) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Type field
type Type struct {
	_updated bool
	val      goption.Option[SongType]
}

func (c *Type) GetType() goption.Option[SongType] {
	return c.val
}

func (c *Type) SetType(val goption.Option[SongType]) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Type) IsUpdated() bool {
	return c._updated
}

func (c *Type) resetUpdated() {
	c._updated = false
}

func (c *Type) GetColumnName() string {
	return "type"
}

func (c *Type) GetValPointer() any {
	return &c.val
}

func (c *Type) getTypeForDB() goption.Option[SongType] {
	return c.val
}

func (c *Type) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Type) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Hash field
// Song file hash checksum
type Hash struct {
	_updated bool
	val      string
}

func (c *Hash) GetHash() string {
	return c.val
}

func (c *Hash) SetHash(val string) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Hash) IsUpdated() bool {
	return c._updated
}

func (c *Hash) resetUpdated() {
	c._updated = false
}

func (c *Hash) GetColumnName() string {
	return "hash"
}

func (c *Hash) GetValPointer() any {
	return &c.val
}

func (c *Hash) getHashForDB() string {
	return c.val
}

func (c *Hash) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Hash) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Remark field
type Remark struct {
	_updated bool
	val      goption.Option[string]
}

func (c *Remark) GetRemark() goption.Option[string] {
	return c.val
}

func (c *Remark) SetRemark(val goption.Option[string]) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Remark) IsUpdated() bool {
	return c._updated
}

func (c *Remark) resetUpdated() {
	c._updated = false
}

func (c *Remark) GetColumnName() string {
	return "remark"
}

func (c *Remark) GetValPointer() any {
	return &c.val
}

func (c *Remark) getRemarkForDB() goption.Option[string] {
	return c.val
}

func (c *Remark) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Remark) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Manifest field
type Manifest struct {
	_updated bool
	val      []byte
}

func (c *Manifest) GetManifest() []byte {
	return c.val
}

func (c *Manifest) SetManifest(val []byte) bool {
	c._updated = true
	c.val = val
	return true
}

func (c *Manifest) IsUpdated() bool {
	return c._updated
}

func (c *Manifest) resetUpdated() {
	c._updated = false
}

func (c *Manifest) GetColumnName() string {
	return "manifest"
}

func (c *Manifest) GetValPointer() any {
	return &c.val
}

func (c *Manifest) getManifestForDB() []byte {
	return c.val
}

func (c *Manifest) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Manifest) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// New return new *Song with default values
func New() *Song {
	return &Song{
		Id{},
		Title{},
		Rank{val: int(0)},
		Type{},
		Hash{},
		Remark{},
		Manifest{val: []byte("man")},
	}
}

// NewWithPK takes "id"
// and returns new *Song with given PK
func NewWithPK(val uint) *Song {
	c := &Song{
		Id{},
		Title{},
		Rank{val: int(0)},
		Type{},
		Hash{},
		Remark{},
		Manifest{val: []byte("man")},
	}
	c.Id.val = val
	c.Id.isAssigned = true
	return c
}

const insertWithoutPK string = "INSERT INTO `songs` (`title`, `rank`, `type`, `hash`, `remark`, `manifest`) values (?, ?, ?, ?, ?, ?)"
const insertWithPK string = "INSERT INTO `songs` (`id`, `title`, `rank`, `type`, `hash`, `remark`, `manifest`) values (?, ?, ?, ?, ?, ?, ?)"

// Insert Song struct to `songs` table
// Deprecated: use the function with context
func (c *Song) Insert() error {
	var result sql.Result
	var err error
	if c.Id.isAssigned {
		result, err = coredb.Exec(DBName, insertWithPK, c.getIdForDB(), c.getTitleForDB(), c.getRankForDB(), c.getTypeForDB(), c.getHashForDB(), c.getRemarkForDB(), c.getManifestForDB())
		if err != nil {
			return err
		}
	} else {
		result, err = coredb.Exec(DBName, insertWithoutPK, c.getTitleForDB(), c.getRankForDB(), c.getTypeForDB(), c.getHashForDB(), c.getRemarkForDB(), c.getManifestForDB())
		if err != nil {
			return err
		}

		id, err := result.LastInsertId()
		if err != nil {
			return err
		}
		c.Id.val = uint(id)
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if affectedRows == 0 {
		return coredb.ErrAvoidInsert
	}

	c.resetUpdated()
	return nil
}

func (c *Song) resetUpdated() {
	c.Title.resetUpdated()
	c.Rank.resetUpdated()
	c.Type.resetUpdated()
	c.Hash.resetUpdated()
	c.Remark.resetUpdated()
	c.Manifest.resetUpdated()
}

// Update Song struct in `songs` table
// Deprecated: use the function with context
func (obj *Song) Update() (bool, error) {
	var updatedFields []string
	var params []any
	if obj.Title.IsUpdated() {
		updatedFields = append(updatedFields, "`title` = ?")
		params = append(params, obj.getTitleForDB())
	}
	if obj.Rank.IsUpdated() {
		updatedFields = append(updatedFields, "`rank` = ?")
		params = append(params, obj.getRankForDB())
	}
	if obj.Type.IsUpdated() {
		updatedFields = append(updatedFields, "`type` = ?")
		params = append(params, obj.getTypeForDB())
	}
	if obj.Hash.IsUpdated() {
		updatedFields = append(updatedFields, "`hash` = ?")
		params = append(params, obj.getHashForDB())
	}
	if obj.Remark.IsUpdated() {
		updatedFields = append(updatedFields, "`remark` = ?")
		params = append(params, obj.getRemarkForDB())
	}
	if obj.Manifest.IsUpdated() {
		updatedFields = append(updatedFields, "`manifest` = ?")
		params = append(params, obj.getManifestForDB())
	}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE `songs` SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE `id` = ?"
	params = append(params, obj.GetId())

	result, err := coredb.Exec(DBName, sql, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	obj.resetUpdated()
	return true, nil
}

// Update Song struct with given fields in `songs` table
// Deprecated: use the function with context
func Update(obj withPK) (bool, error) {
	var updatedFields []string
	var params []any
	var resetFuncs []func()

	val := reflect.ValueOf(obj).Elem()
	updatedFields = make([]string, 0, val.NumField())
	params = make([]any, 0, val.NumField())

	for i := 0; i < val.NumField(); i++ {
		col := val.Field(i).Addr().Interface()

		switch c := col.(type) {
		case *Title:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`title` = ?")
				params = append(params, c.getTitleForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Rank:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`rank` = ?")
				params = append(params, c.getRankForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Type:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`type` = ?")
				params = append(params, c.getTypeForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Hash:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`hash` = ?")
				params = append(params, c.getHashForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Remark:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`remark` = ?")
				params = append(params, c.getRemarkForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Manifest:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`manifest` = ?")
				params = append(params, c.getManifestForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		}
	}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE `songs` SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE `id` = ?"
	params = append(params, obj.GetId())

	result, err := coredb.Exec(DBName, sql, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	for _, f := range resetFuncs {
		f()
	}
	return true, nil
}

const deleteSql string = "DELETE FROM `songs` WHERE `id` = ?"

// DeleteByPK delete a row from songs table with given primary key value
// Deprecated: use the function with context
func DeleteByPK(val uint) error {
	_, err := coredb.Exec(DBName, deleteSql, val)
	return err
}
