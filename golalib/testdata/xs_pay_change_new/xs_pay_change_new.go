// Code generated by gola 0.1.1; DO NOT EDIT.

package xs_pay_change_new

import (
	"database/sql"
	"encoding/json"
	"reflect"
	"strings"

	"github.com/olachat/gola/v2/coredb"
)

const DBName string = "testdata"
const TableName string = "xs_pay_change_new"

// XsPayChangeNew represents `xs_pay_change_new` table
type XsPayChangeNew struct {
	//  bigint(20) unsigned
	Id `json:"id"`
	// 用户ID int(11) unsigned
	Uid `json:"uid"`
	// 记录时间 int(11) unsigned
	Dateline `json:"dateline"`
	// 金额变化，都是正数 int(11) unsigned
	Money `json:"money"`
	// 金额变化方式(pay 充值, consume 消费 income 收入 cash 提现 confiscate 官方没收 refund 原路退款 subsidy 补贴 give 赠送) enum('pay','consume','income','cash','return','income-lock','income-unlock','income-back','back','change','collect','confiscate','cash-back','punish','punish-back','give','refund','subsidy')
	Op `json:"op"`
	// 序列化数据，关联数据 varchar(255)
	Reason `json:"reason"`
	//  varchar(64)
	Subject `json:"subject"`
	// 用户删除 tinyint(1) unsigned
	Deleted `json:"deleted"`
}
type PK struct {
	Id       uint64
	Dateline uint
}

type withPK interface {
	GetId() uint64
	GetDateline() uint
}

// FetchByPK returns a row from `xs_pay_change_new` table with given primary key value
//
// Deprecated: use the function with context
func FetchByPK(val PK) *XsPayChangeNew {
	return coredb.FetchByPK[XsPayChangeNew](DBName, TableName, []string{"id", "dateline"}, val.Id, val.Dateline)
}

// FetchFieldsByPK returns a row with selected fields from xs_pay_change_new table with given primary key value
//
// Deprecated: use the function with context
func FetchFieldsByPK[T any](val PK) *T {
	return coredb.FetchByPK[T](DBName, TableName, []string{"id", "dateline"}, val.Id, val.Dateline)
}

// FindOne returns a row from `xs_pay_change_new` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOne(whereSQL string, params ...any) *XsPayChangeNew {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOne[XsPayChangeNew](DBName, TableName, w)
}

// FindOneFields returns a row with selected fields from `xs_pay_change_new` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFields[T any](whereSQL string, params ...any) *T {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOne[T](DBName, TableName, w)
}

// Find returns rows from `xs_pay_change_new` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func Find(whereSQL string, params ...any) ([]*XsPayChangeNew, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.Find[XsPayChangeNew](DBName, TableName, w)
}

// FindFields returns rows with selected fields from `xs_pay_change_new` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFields[T any](whereSQL string, params ...any) ([]*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.Find[T](DBName, TableName, w)
}

// Count returns select count(*) with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func Count(whereSQL string, params ...any) (int, error) {
	return coredb.QueryInt(DBName, "SELECT COUNT(*) FROM `xs_pay_change_new` "+whereSQL, params...)
}

// FetchByPK returns a row from `xs_pay_change_new` table with given primary key value
//
// Deprecated: use the function with context
func FetchByPKFromMaster(val PK) *XsPayChangeNew {
	return coredb.FetchByPKFromMaster[XsPayChangeNew](DBName, TableName, []string{"id", "dateline"}, val.Id, val.Dateline)
}

// FetchFieldsByPK returns a row with selected fields from xs_pay_change_new table with given primary key value
//
// Deprecated: use the function with context
func FetchFieldsByPKFromMaster[T any](val PK) *T {
	return coredb.FetchByPKFromMaster[T](DBName, TableName, []string{"id", "dateline"}, val.Id, val.Dateline)
}

// FindOne returns a row from `xs_pay_change_new` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFromMaster(whereSQL string, params ...any) *XsPayChangeNew {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneFromMaster[XsPayChangeNew](DBName, TableName, w)
}

// FindOneFields returns a row with selected fields from `xs_pay_change_new` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFieldsFromMaster[T any](whereSQL string, params ...any) *T {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneFromMaster[T](DBName, TableName, w)
}

// Find returns rows from `xs_pay_change_new` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFromMaster(whereSQL string, params ...any) ([]*XsPayChangeNew, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindFromMaster[XsPayChangeNew](DBName, TableName, w)
}

// FindFields returns rows with selected fields from `xs_pay_change_new` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFieldsFromMaster[T any](whereSQL string, params ...any) ([]*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindFromMaster[T](DBName, TableName, w)
}

// Count returns select count(*) with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func CountFromMaster(whereSQL string, params ...any) (int, error) {
	return coredb.QueryIntFromMaster(DBName, "SELECT COUNT(*) FROM `xs_pay_change_new` "+whereSQL, params...)
}

// Column types
type XsPayChangeNewOp string

const (
	XsPayChangeNewOpPay          XsPayChangeNewOp = "pay"
	XsPayChangeNewOpConsume      XsPayChangeNewOp = "consume"
	XsPayChangeNewOpIncome       XsPayChangeNewOp = "income"
	XsPayChangeNewOpCash         XsPayChangeNewOp = "cash"
	XsPayChangeNewOpReturn       XsPayChangeNewOp = "return"
	XsPayChangeNewOpIncomeLock   XsPayChangeNewOp = "income-lock"
	XsPayChangeNewOpIncomeUnlock XsPayChangeNewOp = "income-unlock"
	XsPayChangeNewOpIncomeBack   XsPayChangeNewOp = "income-back"
	XsPayChangeNewOpBack         XsPayChangeNewOp = "back"
	XsPayChangeNewOpChange       XsPayChangeNewOp = "change"
	XsPayChangeNewOpCollect      XsPayChangeNewOp = "collect"
	XsPayChangeNewOpConfiscate   XsPayChangeNewOp = "confiscate"
	XsPayChangeNewOpCashBack     XsPayChangeNewOp = "cash-back"
	XsPayChangeNewOpPunish       XsPayChangeNewOp = "punish"
	XsPayChangeNewOpPunishBack   XsPayChangeNewOp = "punish-back"
	XsPayChangeNewOpGive         XsPayChangeNewOp = "give"
	XsPayChangeNewOpRefund       XsPayChangeNewOp = "refund"
	XsPayChangeNewOpSubsidy      XsPayChangeNewOp = "subsidy"
)

// Id field
type Id struct {
	val uint64
}

func (c *Id) GetId() uint64 {
	return c.val
}

func (c *Id) GetColumnName() string {
	return "id"
}

func (c *Id) GetValPointer() any {
	return &c.val
}

func (c *Id) getIdForDB() uint64 {
	return c.val
}

func (c *Id) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Id) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Uid field
// 用户ID
type Uid struct {
	_updated bool
	val      uint
}

func (c *Uid) GetUid() uint {
	return c.val
}

func (c *Uid) SetUid(val uint) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Uid) IsUpdated() bool {
	return c._updated
}

func (c *Uid) resetUpdated() {
	c._updated = false
}

func (c *Uid) GetColumnName() string {
	return "uid"
}

func (c *Uid) GetValPointer() any {
	return &c.val
}

func (c *Uid) getUidForDB() uint {
	return c.val
}

func (c *Uid) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Uid) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Dateline field
// 记录时间
type Dateline struct {
	val uint
}

func (c *Dateline) GetDateline() uint {
	return c.val
}

func (c *Dateline) GetColumnName() string {
	return "dateline"
}

func (c *Dateline) GetValPointer() any {
	return &c.val
}

func (c *Dateline) getDatelineForDB() uint {
	return c.val
}

func (c *Dateline) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Dateline) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Money field
// 金额变化，都是正数
type Money struct {
	_updated bool
	val      uint
}

func (c *Money) GetMoney() uint {
	return c.val
}

func (c *Money) SetMoney(val uint) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Money) IsUpdated() bool {
	return c._updated
}

func (c *Money) resetUpdated() {
	c._updated = false
}

func (c *Money) GetColumnName() string {
	return "money"
}

func (c *Money) GetValPointer() any {
	return &c.val
}

func (c *Money) getMoneyForDB() uint {
	return c.val
}

func (c *Money) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Money) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Op field
// 金额变化方式(pay 充值, consume 消费 income 收入 cash 提现 confiscate 官方没收 refund 原路退款 subsidy 补贴 give 赠送)
type Op struct {
	_updated bool
	val      XsPayChangeNewOp
}

func (c *Op) GetOp() XsPayChangeNewOp {
	return c.val
}

func (c *Op) SetOp(val XsPayChangeNewOp) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Op) IsUpdated() bool {
	return c._updated
}

func (c *Op) resetUpdated() {
	c._updated = false
}

func (c *Op) GetColumnName() string {
	return "op"
}

func (c *Op) GetValPointer() any {
	return &c.val
}

func (c *Op) getOpForDB() XsPayChangeNewOp {
	return c.val
}

func (c *Op) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Op) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Reason field
// 序列化数据，关联数据
type Reason struct {
	_updated bool
	val      string
}

func (c *Reason) GetReason() string {
	return c.val
}

func (c *Reason) SetReason(val string) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Reason) IsUpdated() bool {
	return c._updated
}

func (c *Reason) resetUpdated() {
	c._updated = false
}

func (c *Reason) GetColumnName() string {
	return "reason"
}

func (c *Reason) GetValPointer() any {
	return &c.val
}

func (c *Reason) getReasonForDB() string {
	return c.val
}

func (c *Reason) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Reason) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Subject field
type Subject struct {
	_updated bool
	val      string
}

func (c *Subject) GetSubject() string {
	return c.val
}

func (c *Subject) SetSubject(val string) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Subject) IsUpdated() bool {
	return c._updated
}

func (c *Subject) resetUpdated() {
	c._updated = false
}

func (c *Subject) GetColumnName() string {
	return "subject"
}

func (c *Subject) GetValPointer() any {
	return &c.val
}

func (c *Subject) getSubjectForDB() string {
	return c.val
}

func (c *Subject) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Subject) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Deleted field
// 用户删除
type Deleted struct {
	_updated bool
	val      bool
}

func (c *Deleted) GetDeleted() bool {
	return c.val
}

func (c *Deleted) SetDeleted(val bool) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Deleted) IsUpdated() bool {
	return c._updated
}

func (c *Deleted) resetUpdated() {
	c._updated = false
}

func (c *Deleted) GetColumnName() string {
	return "deleted"
}

func (c *Deleted) GetValPointer() any {
	return &c.val
}

func (c *Deleted) getDeletedForDB() bool {
	return c.val
}

func (c *Deleted) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Deleted) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// NewWithPK takes "id","dateline"
// and returns new *XsPayChangeNew with given PK
func NewWithPK(val PK) *XsPayChangeNew {
	c := &XsPayChangeNew{
		Id{},
		Uid{val: uint(0)},
		Dateline{val: uint(0)},
		Money{val: uint(0)},
		Op{val: "pay"},
		Reason{},
		Subject{},
		Deleted{val: false},
	}
	c.Id.val = val.Id
	c.Dateline.val = val.Dateline
	return c
}

const insertWithoutPK string = "INSERT INTO `xs_pay_change_new` (`uid`, `dateline`, `money`, `op`, `reason`, `subject`, `deleted`) values (?, ?, ?, ?, ?, ?, ?)"

// Insert XsPayChangeNew struct to `xs_pay_change_new` table
// Deprecated: use the function with context
func (c *XsPayChangeNew) Insert() error {
	var result sql.Result
	var err error
	result, err = coredb.Exec(DBName, insertWithoutPK, c.getUidForDB(), c.getDatelineForDB(), c.getMoneyForDB(), c.getOpForDB(), c.getReasonForDB(), c.getSubjectForDB(), c.getDeletedForDB())
	if err != nil {
		return err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if affectedRows == 0 {
		return coredb.ErrAvoidInsert
	}

	c.resetUpdated()
	return nil
}

func (c *XsPayChangeNew) resetUpdated() {
	c.Uid.resetUpdated()
	c.Money.resetUpdated()
	c.Op.resetUpdated()
	c.Reason.resetUpdated()
	c.Subject.resetUpdated()
	c.Deleted.resetUpdated()
}

// Update XsPayChangeNew struct in `xs_pay_change_new` table
// Deprecated: use the function with context
func (obj *XsPayChangeNew) Update() (bool, error) {
	var updatedFields []string
	var params []any
	if obj.Uid.IsUpdated() {
		updatedFields = append(updatedFields, "`uid` = ?")
		params = append(params, obj.getUidForDB())
	}
	if obj.Money.IsUpdated() {
		updatedFields = append(updatedFields, "`money` = ?")
		params = append(params, obj.getMoneyForDB())
	}
	if obj.Op.IsUpdated() {
		updatedFields = append(updatedFields, "`op` = ?")
		params = append(params, obj.getOpForDB())
	}
	if obj.Reason.IsUpdated() {
		updatedFields = append(updatedFields, "`reason` = ?")
		params = append(params, obj.getReasonForDB())
	}
	if obj.Subject.IsUpdated() {
		updatedFields = append(updatedFields, "`subject` = ?")
		params = append(params, obj.getSubjectForDB())
	}
	if obj.Deleted.IsUpdated() {
		updatedFields = append(updatedFields, "`deleted` = ?")
		params = append(params, obj.getDeletedForDB())
	}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE `xs_pay_change_new` SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE `id` = ? and `dateline` = ?"
	params = append(params, obj.GetId(), obj.GetDateline())

	result, err := coredb.Exec(DBName, sql, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	obj.resetUpdated()
	return true, nil
}

// Update XsPayChangeNew struct with given fields in `xs_pay_change_new` table
// Deprecated: use the function with context
func Update(obj withPK) (bool, error) {
	var updatedFields []string
	var params []any
	var resetFuncs []func()

	val := reflect.ValueOf(obj).Elem()
	updatedFields = make([]string, 0, val.NumField())
	params = make([]any, 0, val.NumField())

	for i := 0; i < val.NumField(); i++ {
		col := val.Field(i).Addr().Interface()

		switch c := col.(type) {
		case *Uid:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`uid` = ?")
				params = append(params, c.getUidForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Money:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`money` = ?")
				params = append(params, c.getMoneyForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Op:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`op` = ?")
				params = append(params, c.getOpForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Reason:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`reason` = ?")
				params = append(params, c.getReasonForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Subject:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`subject` = ?")
				params = append(params, c.getSubjectForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Deleted:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`deleted` = ?")
				params = append(params, c.getDeletedForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		}
	}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE `xs_pay_change_new` SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE `id` = ? and `dateline` = ?"
	params = append(params, obj.GetId(), obj.GetDateline())

	result, err := coredb.Exec(DBName, sql, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	for _, f := range resetFuncs {
		f()
	}
	return true, nil
}

const deleteSql string = "DELETE FROM `xs_pay_change_new` WHERE `id` = ? and `dateline` = ?"

// DeleteByPK delete a row from xs_pay_change_new table with given primary key value
// Deprecated: use the function with context
func DeleteByPK(val PK) error {
	_, err := coredb.Exec(DBName, deleteSql, val.Id, val.Dateline)
	return err
}
