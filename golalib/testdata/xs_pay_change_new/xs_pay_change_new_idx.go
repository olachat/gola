// Code generated by gola 0.1.1; DO NOT EDIT.

package xs_pay_change_new

import (
	"fmt"
	"strings"

	"github.com/olachat/gola/v2/coredb"
)

type orderBy int

type idxQuery[T any] struct {
	whereSql    string
	limitSql    string
	orders      []string
	whereParams []any
}

// order by enum & interface
const (
	IdAsc orderBy = iota
	IdDesc
	UidAsc
	UidDesc
	DatelineAsc
	DatelineDesc
	MoneyAsc
	MoneyDesc
	OpAsc
	OpDesc
	ReasonAsc
	ReasonDesc
	SubjectAsc
	SubjectDesc
	DeletedAsc
	DeletedDesc
)

func (q *idxQuery[T]) OrderBy(args ...orderBy) coredb.ReadQuery[T] {
	q.orders = make([]string, len(args))
	for i, arg := range args {
		switch arg {
		case IdAsc:
			q.orders[i] = "`id` asc"
		case IdDesc:
			q.orders[i] = "`id` desc"
		case UidAsc:
			q.orders[i] = "`uid` asc"
		case UidDesc:
			q.orders[i] = "`uid` desc"
		case DatelineAsc:
			q.orders[i] = "`dateline` asc"
		case DatelineDesc:
			q.orders[i] = "`dateline` desc"
		case MoneyAsc:
			q.orders[i] = "`money` asc"
		case MoneyDesc:
			q.orders[i] = "`money` desc"
		case OpAsc:
			q.orders[i] = "`op` asc"
		case OpDesc:
			q.orders[i] = "`op` desc"
		case ReasonAsc:
			q.orders[i] = "`reason` asc"
		case ReasonDesc:
			q.orders[i] = "`reason` desc"
		case SubjectAsc:
			q.orders[i] = "`subject` asc"
		case SubjectDesc:
			q.orders[i] = "`subject` desc"
		case DeletedAsc:
			q.orders[i] = "`deleted` asc"
		case DeletedDesc:
			q.orders[i] = "`deleted` desc"
		}
	}
	return q
}

// deprecated: use the function with context
func (q *idxQuery[T]) All() []*T {
	result, _ := coredb.Find[T](DBName, TableName, q)
	return result
}

// deprecated: use the function with context
func (q *idxQuery[T]) Limit(offset, limit int) []*T {
	q.limitSql = fmt.Sprintf(" limit %d, %d", offset, limit)
	result, _ := coredb.Find[T](DBName, TableName, q)
	return result
}

// deprecated: use the function with context
func (q *idxQuery[T]) AllFromMaster() []*T {
	result, _ := coredb.FindFromMaster[T](DBName, TableName, q)
	return result
}

// deprecated: use the function with context
func (q *idxQuery[T]) LimitFromMaster(offset, limit int) []*T {
	q.limitSql = fmt.Sprintf(" limit %d, %d", offset, limit)
	result, _ := coredb.FindFromMaster[T](DBName, TableName, q)
	return result
}

type order[T any] interface {
	OrderBy(args ...orderBy) coredb.ReadQuery[T]
}

type orderReadQuery[T any] interface {
	order[T]
	coredb.ReadQuery[T]
}

type iQuery[T any] interface {
	WhereIdEQ(val uint64) iQuery1[T]
	WhereIdIN(vals ...uint64) iQuery1[T]
	WhereUidEQ(val uint) iQuery3[T]
	WhereUidIN(vals ...uint) iQuery3[T]
	orderReadQuery[T]
}
type iQuery1[T any] interface {
	AndDatelineEQ(val uint) orderReadQuery[T]
	AndDatelineIN(vals ...uint) orderReadQuery[T]
	orderReadQuery[T]
}

type iQuery3[T any] interface {
	AndDeletedEQ(val bool) iQuery4[T]
	AndDeletedIN(vals ...bool) iQuery4[T]
	orderReadQuery[T]
}

type iQuery4[T any] interface {
	AndDatelineEQ(val uint) iQuery5[T]
	AndDatelineIN(vals ...uint) iQuery5[T]
	orderReadQuery[T]
}

type iQuery5[T any] interface {
	AndOpEQ(val XsPayChangeNewOp) orderReadQuery[T]
	AndOpIN(vals ...XsPayChangeNewOp) orderReadQuery[T]
	orderReadQuery[T]
}

type idxQuery1[T any] struct {
	*idxQuery[T]
}

func (q *idxQuery1[T]) AndDatelineEQ(val uint) orderReadQuery[T] {
	q.whereSql += " and `dateline` = ?"
	q.whereParams = append(q.whereParams, val)
	return q.idxQuery
}

func (q *idxQuery1[T]) AndDatelineIN(vals ...uint) orderReadQuery[T] {
	q.whereSql += " and `dateline` in (" + coredb.GetParamPlaceHolder(len(vals)) + ")"
	for _, val := range vals {
		q.whereParams = append(q.whereParams, val)
	}
	return q.idxQuery
}

type idxQuery3[T any] struct {
	*idxQuery[T]
}

func (q *idxQuery3[T]) AndDeletedEQ(val bool) iQuery4[T] {
	q.whereSql += " and `deleted` = ?"
	q.whereParams = append(q.whereParams, val)
	return &idxQuery4[T]{q.idxQuery}
}

func (q *idxQuery3[T]) AndDeletedIN(vals ...bool) iQuery4[T] {
	q.whereSql += " and `deleted` in (" + coredb.GetParamPlaceHolder(len(vals)) + ")"
	for _, val := range vals {
		q.whereParams = append(q.whereParams, val)
	}
	return &idxQuery4[T]{q.idxQuery}
}

type idxQuery4[T any] struct {
	*idxQuery[T]
}

func (q *idxQuery4[T]) AndDatelineEQ(val uint) iQuery5[T] {
	q.whereSql += " and `dateline` = ?"
	q.whereParams = append(q.whereParams, val)
	return &idxQuery5[T]{q.idxQuery}
}

func (q *idxQuery4[T]) AndDatelineIN(vals ...uint) iQuery5[T] {
	q.whereSql += " and `dateline` in (" + coredb.GetParamPlaceHolder(len(vals)) + ")"
	for _, val := range vals {
		q.whereParams = append(q.whereParams, val)
	}
	return &idxQuery5[T]{q.idxQuery}
}

type idxQuery5[T any] struct {
	*idxQuery[T]
}

func (q *idxQuery5[T]) AndOpEQ(val XsPayChangeNewOp) orderReadQuery[T] {
	q.whereSql += " and `op` = ?"
	q.whereParams = append(q.whereParams, val)
	return q.idxQuery
}

func (q *idxQuery5[T]) AndOpIN(vals ...XsPayChangeNewOp) orderReadQuery[T] {
	q.whereSql += " and `op` in (" + coredb.GetParamPlaceHolder(len(vals)) + ")"
	for _, val := range vals {
		q.whereParams = append(q.whereParams, val)
	}
	return q.idxQuery
}

// Find methods

// Select returns rows from `xs_pay_change_new` table with index awared query
func Select() iQuery[XsPayChangeNew] {
	return new(idxQuery[XsPayChangeNew])
}

// SelectFields returns rows with selected fields from `xs_pay_change_new` table with index awared query
func SelectFields[T any]() iQuery[T] {
	return new(idxQuery[T])
}

func (q *idxQuery[T]) WhereIdEQ(val uint64) iQuery1[T] {
	q.whereSql += " where `id` = ?"
	q.whereParams = append(q.whereParams, val)
	return &idxQuery1[T]{q}
}

func (q *idxQuery[T]) WhereIdIN(vals ...uint64) iQuery1[T] {
	q.whereSql = " where `id` in (" + coredb.GetParamPlaceHolder(len(vals)) + ")"
	for _, val := range vals {
		q.whereParams = append(q.whereParams, val)
	}
	return &idxQuery1[T]{q}
}

func (q *idxQuery[T]) WhereUidEQ(val uint) iQuery3[T] {
	q.whereSql += " where `uid` = ?"
	q.whereParams = append(q.whereParams, val)
	return &idxQuery3[T]{q}
}

func (q *idxQuery[T]) WhereUidIN(vals ...uint) iQuery3[T] {
	q.whereSql = " where `uid` in (" + coredb.GetParamPlaceHolder(len(vals)) + ")"
	for _, val := range vals {
		q.whereParams = append(q.whereParams, val)
	}
	return &idxQuery3[T]{q}
}

func (q *idxQuery[T]) GetWhere() (whereSql string, params []any) {
	var orderSql string
	if len(q.orders) > 0 {
		orderSql = " order by " + strings.Join(q.orders, ",")
	}
	return q.whereSql + orderSql + q.limitSql, q.whereParams
}
