// Code generated by gola 0.1.1; DO NOT EDIT.

package wallet

import (
	"database/sql"
	"encoding/json"
	"reflect"
	"strings"

	"github.com/olachat/gola/v2/coredb"

	"github.com/jordan-bonecutter/goption"
)

const DBName string = "testdata"
const TableName string = "wallet"

// Wallet represents `wallet` table
type Wallet struct {
	//  int(11)
	UserId `json:"user_id"`
	//  tinyint(2)
	WalletType `json:"wallet_type"`
	//  varchar(50)
	WalletName `json:"wallet_name"`
	// money bigint(20)
	Money `json:"money"`
}
type PK struct {
	UserId     int
	WalletType int8
}

type withPK interface {
	GetUserId() int
	GetWalletType() int8
}

// FetchByPK returns a row from `wallet` table with given primary key value
//
// Deprecated: use the function with context
func FetchByPK(val PK) *Wallet {
	return coredb.FetchByPK[Wallet](DBName, TableName, []string{"user_id", "wallet_type"}, val.UserId, val.WalletType)
}

// FetchFieldsByPK returns a row with selected fields from wallet table with given primary key value
//
// Deprecated: use the function with context
func FetchFieldsByPK[T any](val PK) *T {
	return coredb.FetchByPK[T](DBName, TableName, []string{"user_id", "wallet_type"}, val.UserId, val.WalletType)
}

// FindOne returns a row from `wallet` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOne(whereSQL string, params ...any) *Wallet {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOne[Wallet](DBName, TableName, w)
}

// FindOneFields returns a row with selected fields from `wallet` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFields[T any](whereSQL string, params ...any) *T {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOne[T](DBName, TableName, w)
}

// Find returns rows from `wallet` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func Find(whereSQL string, params ...any) ([]*Wallet, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.Find[Wallet](DBName, TableName, w)
}

// FindFields returns rows with selected fields from `wallet` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFields[T any](whereSQL string, params ...any) ([]*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.Find[T](DBName, TableName, w)
}

// Count returns select count(*) with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func Count(whereSQL string, params ...any) (int, error) {
	return coredb.QueryInt(DBName, "SELECT COUNT(*) FROM `wallet` "+whereSQL, params...)
}

// FetchByPK returns a row from `wallet` table with given primary key value
//
// Deprecated: use the function with context
func FetchByPKFromMaster(val PK) *Wallet {
	return coredb.FetchByPKFromMaster[Wallet](DBName, TableName, []string{"user_id", "wallet_type"}, val.UserId, val.WalletType)
}

// FetchFieldsByPK returns a row with selected fields from wallet table with given primary key value
//
// Deprecated: use the function with context
func FetchFieldsByPKFromMaster[T any](val PK) *T {
	return coredb.FetchByPKFromMaster[T](DBName, TableName, []string{"user_id", "wallet_type"}, val.UserId, val.WalletType)
}

// FindOne returns a row from `wallet` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFromMaster(whereSQL string, params ...any) *Wallet {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneFromMaster[Wallet](DBName, TableName, w)
}

// FindOneFields returns a row with selected fields from `wallet` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindOneFieldsFromMaster[T any](whereSQL string, params ...any) *T {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneFromMaster[T](DBName, TableName, w)
}

// Find returns rows from `wallet` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFromMaster(whereSQL string, params ...any) ([]*Wallet, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindFromMaster[Wallet](DBName, TableName, w)
}

// FindFields returns rows with selected fields from `wallet` table with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func FindFieldsFromMaster[T any](whereSQL string, params ...any) ([]*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindFromMaster[T](DBName, TableName, w)
}

// Count returns select count(*) with arbitary where query
// whereSQL must start with "where ..."
//
// Deprecated: use the function with context
func CountFromMaster(whereSQL string, params ...any) (int, error) {
	return coredb.QueryIntFromMaster(DBName, "SELECT COUNT(*) FROM `wallet` "+whereSQL, params...)
}

// Column types

// UserId field
type UserId struct {
	val int
}

func (c *UserId) GetUserId() int {
	return c.val
}

func (c *UserId) GetColumnName() string {
	return "user_id"
}

func (c *UserId) GetValPointer() any {
	return &c.val
}

func (c *UserId) getUserIdForDB() int {
	return c.val
}

func (c *UserId) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *UserId) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// WalletType field
type WalletType struct {
	val int8
}

func (c *WalletType) GetWalletType() int8 {
	return c.val
}

func (c *WalletType) GetColumnName() string {
	return "wallet_type"
}

func (c *WalletType) GetValPointer() any {
	return &c.val
}

func (c *WalletType) getWalletTypeForDB() int8 {
	return c.val
}

func (c *WalletType) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *WalletType) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// WalletName field
type WalletName struct {
	_updated bool
	val      goption.Option[string]
}

func (c *WalletName) GetWalletName() goption.Option[string] {
	return c.val
}

func (c *WalletName) SetWalletName(val goption.Option[string]) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *WalletName) IsUpdated() bool {
	return c._updated
}

func (c *WalletName) resetUpdated() {
	c._updated = false
}

func (c *WalletName) GetColumnName() string {
	return "wallet_name"
}

func (c *WalletName) GetValPointer() any {
	return &c.val
}

func (c *WalletName) getWalletNameForDB() goption.Option[string] {
	return c.val
}

func (c *WalletName) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *WalletName) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// Money field
// money
type Money struct {
	_updated bool
	val      int64
}

func (c *Money) GetMoney() int64 {
	return c.val
}

func (c *Money) SetMoney(val int64) bool {
	if c.val == val {
		return false
	}
	c._updated = true
	c.val = val
	return true
}

func (c *Money) IsUpdated() bool {
	return c._updated
}

func (c *Money) resetUpdated() {
	c._updated = false
}

func (c *Money) GetColumnName() string {
	return "money"
}

func (c *Money) GetValPointer() any {
	return &c.val
}

func (c *Money) getMoneyForDB() int64 {
	return c.val
}

func (c *Money) MarshalJSON() ([]byte, error) {
	return json.Marshal(&c.val)
}

func (c *Money) UnmarshalJSON(data []byte) error {
	if err := json.Unmarshal(data, &c.val); err != nil {
		return err
	}

	return nil
}

// NewWithPK takes "user_id","wallet_type"
// and returns new *Wallet with given PK
func NewWithPK(val PK) *Wallet {
	c := &Wallet{
		UserId{},
		WalletType{},
		WalletName{},
		Money{val: int64(0)},
	}
	c.UserId.val = val.UserId
	c.WalletType.val = val.WalletType
	return c
}

const insertWithoutPK string = "INSERT INTO `wallet` (`user_id`, `wallet_type`, `wallet_name`, `money`) values (?, ?, ?, ?)"

// Insert Wallet struct to `wallet` table
// Deprecated: use the function with context
func (c *Wallet) Insert() error {
	var result sql.Result
	var err error
	result, err = coredb.Exec(DBName, insertWithoutPK, c.getUserIdForDB(), c.getWalletTypeForDB(), c.getWalletNameForDB(), c.getMoneyForDB())
	if err != nil {
		return err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if affectedRows == 0 {
		return coredb.ErrAvoidInsert
	}

	c.resetUpdated()
	return nil
}

func (c *Wallet) resetUpdated() {
	c.WalletName.resetUpdated()
	c.Money.resetUpdated()
}

// Update Wallet struct in `wallet` table
// Deprecated: use the function with context
func (obj *Wallet) Update() (bool, error) {
	var updatedFields []string
	var params []any
	if obj.WalletName.IsUpdated() {
		updatedFields = append(updatedFields, "`wallet_name` = ?")
		params = append(params, obj.getWalletNameForDB())
	}
	if obj.Money.IsUpdated() {
		updatedFields = append(updatedFields, "`money` = ?")
		params = append(params, obj.getMoneyForDB())
	}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE `wallet` SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE `user_id` = ? and `wallet_type` = ?"
	params = append(params, obj.GetUserId(), obj.GetWalletType())

	result, err := coredb.Exec(DBName, sql, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	obj.resetUpdated()
	return true, nil
}

// Update Wallet struct with given fields in `wallet` table
// Deprecated: use the function with context
func Update(obj withPK) (bool, error) {
	var updatedFields []string
	var params []any
	var resetFuncs []func()

	val := reflect.ValueOf(obj).Elem()
	updatedFields = make([]string, 0, val.NumField())
	params = make([]any, 0, val.NumField())

	for i := 0; i < val.NumField(); i++ {
		col := val.Field(i).Addr().Interface()

		switch c := col.(type) {
		case *WalletName:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`wallet_name` = ?")
				params = append(params, c.getWalletNameForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		case *Money:
			if c.IsUpdated() {
				updatedFields = append(updatedFields, "`money` = ?")
				params = append(params, c.getMoneyForDB())
				resetFuncs = append(resetFuncs, c.resetUpdated)
			}
		}
	}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE `wallet` SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE `user_id` = ? and `wallet_type` = ?"
	params = append(params, obj.GetUserId(), obj.GetWalletType())

	result, err := coredb.Exec(DBName, sql, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	for _, f := range resetFuncs {
		f()
	}
	return true, nil
}

const deleteSql string = "DELETE FROM `wallet` WHERE `user_id` = ? and `wallet_type` = ?"

// DeleteByPK delete a row from wallet table with given primary key value
// Deprecated: use the function with context
func DeleteByPK(val PK) error {
	_, err := coredb.Exec(DBName, deleteSql, val.UserId, val.WalletType)
	return err
}
