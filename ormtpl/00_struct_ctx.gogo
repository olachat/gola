// Code generated by gola {{.GetVersion}}; DO NOT EDIT.

package {{.Package}}
{{$table := .}}
import (
	"context"
	"database/sql"
	"reflect"
	"strings"

	"github.com/olachat/gola/v2/coredb"
)

// FetchByPK returns a row from `{{.Name}}` table with given primary key value
func FetchByPKCtx(ctx context.Context, val {{.GetPrimaryKeyType}}) (*{{.ClassName}}, error) {
	return coredb.FetchByPKCtx[{{.ClassName}}](ctx, DBName, TableName, []string{ {{.GetPrimaryKeyNames}} }, {{.GetPrimaryKeyVals}})
}
// FetchFieldsByPK returns a row with selected fields from {{.Name}} table with given primary key value
func FetchFieldsByPKCtx[T any](ctx context.Context, val {{.GetPrimaryKeyType}}) (*T, error) {
	return coredb.FetchByPKCtx[T](ctx, DBName, TableName, []string{ {{.GetPrimaryKeyNames}} }, {{.GetPrimaryKeyVals}})
}
{{- if not .HasCompositePrimaryKey }}
// FetchByPKs returns rows with from `{{.Name}}` table with given primary key values
func FetchByPKsCtx(ctx context.Context, vals ...{{.GetPrimaryKeyType}}) ([]*{{.ClassName}}, error) {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKsCtx[{{.ClassName}}](ctx, DBName, TableName, "{{.GetPrimaryKeyName}}", pks)
}

// FetchFieldsByPKs returns rows with selected fields from `{{.Name}}` table with given primary key values
func FetchFieldsByPKsCtx[T any](ctx context.Context, vals ...{{.GetPrimaryKeyType}}) ([]*T, error) {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKsCtx[T](ctx, DBName, TableName, "{{.GetPrimaryKeyName}}", pks)
}
{{- end}}

// FindOne returns a row from `{{.Name}}` table with arbitary where query
// whereSQL must start with "where ..."
func FindOneCtx(ctx context.Context, whereSQL string, params ...any) (*{{.ClassName}}, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneCtx[{{.ClassName}}](ctx, DBName, TableName, w)
}

// FindOneFields returns a row with selected fields from `{{.Name}}` table with arbitary where query
// whereSQL must start with "where ..."
func FindOneFieldsCtx[T any](ctx context.Context, whereSQL string, params ...any) (*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneCtx[T](ctx, DBName, TableName, w)
}

// Find returns rows from `{{.Name}}` table with arbitary where query
// whereSQL must start with "where ..."
func FindCtx(ctx context.Context, whereSQL string, params ...any) ([]*{{.ClassName}}, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindCtx[{{.ClassName}}](ctx, DBName, TableName, w)
}

// FindFields returns rows with selected fields from `{{.Name}}` table with arbitary where query
// whereSQL must start with "where ..."
func FindFieldsCtx[T any](ctx context.Context, whereSQL string, params ...any) ([]*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindCtx[T](ctx, DBName, TableName, w)
}

// Count returns select count(*) with arbitary where query
// whereSQL must start with "where ..."
func CountCtx(ctx context.Context, whereSQL string, params ...any) (int, error) {
	return coredb.QueryIntCtx(ctx, DBName, "SELECT COUNT(*) FROM `{{.Name}}` " + whereSQL, params...)
}

// FetchByPK returns a row from `{{.Name}}` table with given primary key value
func FetchByPKFromMasterCtx(ctx context.Context, val {{.GetPrimaryKeyType}}) (*{{.ClassName}}, error) {
	return coredb.FetchByPKFromMasterCtx[{{.ClassName}}](ctx, DBName, TableName, []string{ {{.GetPrimaryKeyNames}} }, {{.GetPrimaryKeyVals}})
}
// FetchFieldsByPK returns a row with selected fields from {{.Name}} table with given primary key value
func FetchFieldsByPKFromMasterCtx[T any](ctx context.Context, val {{.GetPrimaryKeyType}}) (*T, error) {
	return coredb.FetchByPKFromMasterCtx[T](ctx, DBName, TableName, []string{ {{.GetPrimaryKeyNames}} }, {{.GetPrimaryKeyVals}})
}
{{- if not .HasCompositePrimaryKey }}
// FetchByPKs returns rows with from `{{.Name}}` table with given primary key values
func FetchByPKsFromMasterCtx(ctx context.Context, vals ...{{.GetPrimaryKeyType}}) ([]*{{.ClassName}}, error) {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKsFromMasterCtx[{{.ClassName}}](ctx, DBName, TableName, "{{.GetPrimaryKeyName}}", pks)
}

// FetchFieldsByPKs returns rows with selected fields from `{{.Name}}` table with given primary key values
func FetchFieldsByPKsFromMasterCtx[T any](ctx context.Context, vals ...{{.GetPrimaryKeyType}}) ([]*T, error) {
	pks := coredb.GetAnySlice(vals)
	return coredb.FetchByPKsFromMasterCtx[T](ctx, DBName, TableName, "{{.GetPrimaryKeyName}}", pks)
}
{{- end}}

// FindOne returns a row from `{{.Name}}` table with arbitary where query
// whereSQL must start with "where ..."
func FindOneFromMasterCtx(ctx context.Context, whereSQL string, params ...any) (*{{.ClassName}}, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneFromMasterCtx[{{.ClassName}}](ctx, DBName, TableName, w)
}

// FindOneFields returns a row with selected fields from `{{.Name}}` table with arbitary where query
// whereSQL must start with "where ..."
func FindOneFieldsFromMasterCtx[T any](ctx context.Context, whereSQL string, params ...any) (*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindOneFromMasterCtx[T](ctx, DBName, TableName, w)
}

// Find returns rows from `{{.Name}}` table with arbitary where query
// whereSQL must start with "where ..."
func FindFromMasterCtx(ctx context.Context, whereSQL string, params ...any) ([]*{{.ClassName}}, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindFromMasterCtx[{{.ClassName}}](ctx, DBName, TableName, w)
}

// FindFields returns rows with selected fields from `{{.Name}}` table with arbitary where query
// whereSQL must start with "where ..."
func FindFieldsFromMasterCtx[T any](ctx context.Context, whereSQL string, params ...any) ([]*T, error) {
	w := coredb.NewWhere(whereSQL, params...)
	return coredb.FindFromMasterCtx[T](ctx, DBName, TableName, w)
}

// Count returns select count(*) with arbitary where query
// whereSQL must start with "where ..."
func CountFromMasterCtx(ctx context.Context, whereSQL string, params ...any) (int, error) {
	return coredb.QueryIntFromMasterCtx(ctx, DBName, "SELECT COUNT(*) FROM `{{.Name}}` " + whereSQL, params...)
}

// Insert {{.ClassName}} struct to `{{.Name}}` table
func (c *{{.ClassName}}) InsertCtx(ctx context.Context) error {
	var result sql.Result
	var err error

	{{- if .IsPKAutoGenerated }}
	if c.{{.GetPrimaryKey}}.isAssigned {
		result, err = coredb.ExecCtx(ctx, DBName, insertWithPK, {{- range $i, $c := .Columns }}
		{{- if $i}}, {{end}}c.get{{$c.GoName}}ForDB()
		{{- end }})
		if err != nil {
			return err
		}
	} else {
		result, err = coredb.ExecCtx(ctx, DBName, insertWithoutPK, {{- range $i, $c := .GetNonAutoIncrementColumns }}
		{{- if $i}}, {{end}}c.get{{$c.GoName}}ForDB()
		{{- end }})
		if err != nil {
			return err
		}

		id, err := result.LastInsertId()
		if err != nil {
			return err
		}
		c.{{.GetPrimaryKey}}.val = {{.GetPrimaryKeyType}}(id)
	}
	{{else}}
	result, err = coredb.ExecCtx(ctx, DBName, insertWithoutPK, {{- range $i, $c := .GetNonAutoIncrementColumns }}
		{{- if $i}}, {{end}}c.get{{$c.GoName}}ForDB()
		{{- end }})
	if err != nil {
		return err
	}
	{{- end}}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return err
	}
	if affectedRows == 0 {
		return coredb.ErrAvoidInsert
	}

	c.resetUpdated()
	return nil
}

// Update {{.ClassName}} struct in `{{.Name}}` table
func (obj *{{.ClassName}}) UpdateCtx(ctx context.Context) (bool, error) {
	var updatedFields []string
	var params []any

	{{- range $i, $c := .GetNonPKColumns }}
	if obj.{{ $c.GoName }}.IsUpdated() {
		updatedFields = append(updatedFields, "`{{ $c.Name }}` = ?")
		params = append(params, obj.get{{$c.GoName}}ForDB())
	}
	{{- end }}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE `{{.Name}}` SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE {{.GetPrimaryKeySQL}}"
	params = append(params, {{.GetPrimaryKeyParams}})

	result, err := coredb.ExecCtx(ctx, DBName, sql, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	obj.resetUpdated()
	return true, nil
}

// Update {{.ClassName}} struct with given fields in `{{.Name}}` table
func UpdateCtx(ctx context.Context, obj withPK) (bool, error) {
	var updatedFields []string
	var params []any
	var resetFuncs []func()

	val := reflect.ValueOf(obj).Elem()
	updatedFields = make([]string, 0, val.NumField())
	params = make([]any, 0, val.NumField())

	for i := 0; i < val.NumField(); i++ {
		col := val.Field(i).Addr().Interface()

		switch c := col.(type) {
		{{- range $i, $c := .GetNonPKColumns }}
		case *{{.GoName}}:
		if c.IsUpdated() {
			updatedFields = append(updatedFields, "`{{ $c.Name }}` = ?")
			params = append(params, c.get{{$c.GoName}}ForDB())
			resetFuncs = append(resetFuncs, c.resetUpdated)
		}
		{{- end }}
		}
	}

	if len(updatedFields) == 0 {
		return false, nil
	}

	sql := "UPDATE `{{.Name}}` SET "
	sql = sql + strings.Join(updatedFields, ",") + " WHERE {{.GetPrimaryKeySQL}}"
	params = append(params, {{.GetPrimaryKeyParams}})

	result, err := coredb.ExecCtx(ctx, DBName, sql, params...)
	if err != nil {
		return false, err
	}

	affectedRows, err := result.RowsAffected()
	if err != nil {
		return false, err
	}
	if affectedRows == 0 {
		return false, coredb.ErrAvoidUpdate
	}

	for _, f := range resetFuncs {
		f()
	}
	return true, nil
}

// DeleteByPK delete a row from {{.Name}} table with given primary key value
func DeleteByPKCtx(ctx context.Context, val {{.GetPrimaryKeyType}}) (error) {
	_, err := coredb.ExecCtx(ctx, DBName, deleteSql, {{.GetPrimaryKeyVals}})
	return err
}
