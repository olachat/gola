package structs

import (
	"sort"
	"strings"
)

// Table struct represent table information read from mysql
type Table struct {
	Name string `json:"name"`
	// For dbs with real schemas, like Postgres.
	// Example value: "schema_name"."table_name"
	SchemaName string   `json:"schema_name"`
	Columns    []Column `json:"columns"`

	PKey  *PrimaryKey  `json:"p_key"`
	FKeys []ForeignKey `json:"f_keys"`

	IsJoinTable bool `json:"is_join_table"`
	Indexes     map[string][]*IndexDesc
	version     string
	idxRoot     *IdxNode
}

// SetVersion for code gen
func (t *Table) SetVersion(version string) {
	t.version = version
}

// GetVersion for code gen
func (t *Table) GetVersion() string {
	return t.version
}

// GetName for code gen
func (t *Table) GetName() string {
	return t.Name
}

// Package returns the package name for the table
func (t *Table) Package() string {
	return t.Name
}

// ClassName returns the go struct(class) name for the table
func (t *Table) ClassName() string {
	name := getGoName(t.Name)
	if strings.HasSuffix(name, "s") {
		return name[:len(name)-1]
	}

	return name
}

// GetPrimaryKey returns the field name of the primary key
func (t *Table) GetPrimaryKey() string {
	for _, c := range t.Columns {
		if c.IsPrimaryKey() {
			return c.GoName()
		}
	}

	return ""
}

// GetPrimaryKeyType returns the go type of the primary key
func (t *Table) GetPrimaryKeyType() string {
	if t.HasCompositePrimaryKey() {
		return "PK"
	}
	for _, c := range t.Columns {
		if c.IsPrimaryKey() {
			return c.GoType()
		}
	}

	return ""
}

// GetPrimaryKeyName returns the first column name of the primary key
func (t *Table) GetPrimaryKeyName() string {
	return t.GetPKColumns()[0].Name
}

// GetPrimaryKeySQL returns primary key for sql where condition
func (t *Table) GetPrimaryKeySQL() string {
	var result []string
	for _, c := range t.GetPKColumns() {
		result = append(result, "`"+c.Name+"` = ?")
	}

	return strings.Join(result, " and ")
}

// GetPrimaryKeyNames returns the column name of the primary key
func (t *Table) GetPrimaryKeyNames() string {
	var result []string
	for _, c := range t.GetPKColumns() {
		result = append(result, "\""+c.Name+"\"")
	}

	return strings.Join(result, ",")
}

// GetPrimaryKeyVals returns str representation of primary key val
func (t *Table) GetPrimaryKeyVals() string {
	cols := t.GetPKColumns()
	if len(cols) == 1 {
		return "val"
	}

	var result []string
	for _, c := range cols {
		result = append(result, "val."+c.GoName())
	}

	return strings.Join(result, ", ")
}

// GetPrimaryKeyParams returns primary key for parameters
func (t *Table) GetPrimaryKeyParams() string {
	var result []string
	for _, c := range t.GetPKColumns() {
		result = append(result, "obj.Get"+c.GoName()+"()")
	}

	return strings.Join(result, ", ")
}

// IsPKAutoGenerated returns all columns needed for insert
func (t *Table) IsPKAutoGenerated() bool {
	cols := t.GetPKColumns()
	if len(cols) == 1 && cols[0].IsAutoIncrement() {
		return true
	}

	return false
}

// GetPKColumns returns all primary key columns
func (t *Table) GetPKColumns() []Column {
	result := make([]Column, 0, len(t.Columns))

	for _, c := range t.Columns {
		if c.IsPrimaryKey() {
			result = append(result, c)
		}
	}
	return result
}

// HasCompositePrimaryKey returns if the table has composite primary keys
func (t *Table) HasCompositePrimaryKey() bool {
	return len(t.GetPKColumns()) > 1
}

// GetNonAutoIncrementColumns returns all columns except having auto incremented value
func (t *Table) GetNonAutoIncrementColumns() []Column {
	result := make([]Column, 0, len(t.Columns))

	for _, c := range t.Columns {
		if !c.IsAutoIncrement() {
			result = append(result, c)
		}
	}

	return result
}

// GetNonPKColumns returns all columns except primary key
func (t *Table) GetNonPKColumns() []Column {
	result := make([]Column, 0, len(t.Columns))

	for _, c := range t.Columns {
		if !c.IsPrimaryKey() {
			result = append(result, c)
		}
	}

	return result
}

// GetIndexRoot returns the root index node
func (t *Table) GetIndexRoot() *IdxNode {
	if t.idxRoot != nil {
		return t.idxRoot
	}

	root := &IdxNode{
		ColName: "",
	}

	idxNames := make([]string, 0, len(t.Indexes))
	for idxName := range t.Indexes {
		idxNames = append(idxNames, idxName)
	}

	sort.Slice(idxNames, func(i, j int) bool {
		return idxNames[i] < idxNames[j]
	})

	for _, idxName := range idxNames {
		items := t.Indexes[idxName]
		node := root
		for _, item := range items {
			node = node.GetChildren(item.ColumnName)
		}
	}

	t.idxRoot = root
	return t.idxRoot
}

// GetIndexNodes returns all index nodes need customized interface
// i.e. has non-empty children nodes
func (t *Table) GetIndexNodes() []*IdxNode {
	allNodes := t.GetIndexRoot().GetAllChildren()
	nodes := make([]*IdxNode, 0, len(allNodes))
	for _, n := range allNodes {
		if len(n.Children) > 0 {
			n.Column = t.GetColumn(n.ColName)
			for _, c := range n.Children {
				c.Column = t.GetColumn(c.ColName)
			}
			nodes = append(nodes, n)
		}

	}
	return nodes
}

// FirstIdxColumns returns first column of all indexes
func (t *Table) FirstIdxColumns() []*IdxNode {
	cols := t.GetIndexRoot().Children

	for _, col := range cols {
		col.Column = t.GetColumn(col.ColName)
	}

	return cols
}

// Imports returns new packages needed to import
func (t *Table) Imports() string {
	packages := make(map[string]bool)
	for _, c := range t.Columns {
		goType := c.GoType()
		if goType == "time.Time" {
			packages[`"time"`] = true
		}
		if goType == "goption.Option[time.Time]" {
			packages[`"time"`] = true
		}

		if goType == "null.String" {
			packages[`"github.com/volatiletech/null/v8"`] = true
		}
		if strings.HasPrefix(goType, "goption") {
			packages[`"github.com/jordan-bonecutter/goption"`] = true
		}
	}

	imports := []string{}
	for p := range packages {
		imports = append(imports, p)
	}

	sort.Slice(imports, func(i, j int) bool {
		return imports[i] > imports[j]
	})

	return strings.Join(imports, "\n")
}
